use async_openai::types::{
    ChatCompletionRequestMessage, ChatCompletionRequestMessageContentPartImage,
    ChatCompletionRequestMessageContentPartText, ChatCompletionRequestSystemMessageArgs,
    ChatCompletionRequestUserMessageArgs, ChatCompletionRequestUserMessageContent,
    ChatCompletionRequestUserMessageContentPart, CreateChatCompletionRequestArgs, ImageDetail,
    ImageUrl,
};
use axum::{Extension, Json};
use axum_valid::Valid;
use base64::{Engine as _, engine::general_purpose};
use chrono::Utc;
use color_eyre::eyre::eyre;
use sea_orm::{ActiveModelTrait, ActiveValue::Set, ColumnTrait, EntityTrait, QueryFilter};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use utoipa_axum::{router::OpenApiRouter, routes};
use validator::Validate;

use crate::{
    entity::{file, note, user},
    errors::{AxumError, AxumResult},
    middlewares::UnauthorizedError,
    routes::api::notes::NoteCreateResponse,
    state::AppState,
};

pub fn routes() -> OpenApiRouter<AppState> {
    OpenApiRouter::new().routes(routes!(create_ai_note))
}

#[derive(Deserialize, ToSchema, Validate)]
pub struct AiNoteCreateRequest {
    pub title: String,
    pub prompt: String,
    pub files: Vec<i32>,
    pub public: Option<bool>,
}

/// Create note with images using AI
///
/// Returns generated note content
#[utoipa::path(
    method(post),
    path = "/",
    responses(
        (status = OK, description = "Success", body = AiNoteCreateResponse),
        (status = UNAUTHORIZED, description = "Unauthorized", body = UnauthorizedError)
    ),
    tag = "Notes"
)]
pub async fn create_ai_note(
    Extension(state): Extension<AppState>,
    Extension(user): Extension<user::Model>,
    Valid(Json(body)): Valid<Json<AiNoteCreateRequest>>,
) -> AxumResult<Json<AiNoteCreateResponse>> {
    let files = file::Entity::find()
        .filter(file::Column::Id.is_in(body.files))
        .all(&state.db)
        .await?;

    let mut message_content = vec![ChatCompletionRequestUserMessageContentPart::Text(
        ChatCompletionRequestMessageContentPartText {
            text: body.prompt.clone(),
        },
    )];

    for file in files {
        let mime_type = if file.filename.to_lowercase().ends_with(".png") {
            "image/png"
        } else if file.filename.to_lowercase().ends_with(".jpg")
            || file.filename.to_lowercase().ends_with(".jpeg")
        {
            "image/jpeg"
        } else if file.filename.to_lowercase().ends_with(".gif") {
            "image/gif"
        } else if file.filename.to_lowercase().ends_with(".webp") {
            "image/webp"
        } else {
            "image/jpeg"
        };

        let base64_data = general_purpose::STANDARD.encode(&file.data);

        let data_url = format!("data:{};base64,{}", mime_type, base64_data);

        message_content.push(ChatCompletionRequestUserMessageContentPart::ImageUrl(
            ChatCompletionRequestMessageContentPartImage {
                image_url: ImageUrl {
                    url: data_url,
                    detail: Some(ImageDetail::Auto),
                },
            },
        ));
    }

    let system_message = ChatCompletionRequestSystemMessageArgs::default()
        .content("You are given images containing handwritten or printed notes from a workbook. Produce one complete, well-structured text note based strictly on the content visible in the images. Output only the final note as plain text with no introductions, explanations, comments, or descriptions. Use the same language that appears in the images. Include all information from all images, merge it into one coherent note, and do not repeat content. Do not add or guess information that is not present. You may rephrase only to improve clarity while keeping the meaning identical. Exhaust the topic using only what is shown in the images.")
        .build()?;

    let user_message = ChatCompletionRequestUserMessageArgs::default()
        .content(ChatCompletionRequestUserMessageContent::Array(
            message_content,
        ))
        .build()?;

    let request = CreateChatCompletionRequestArgs::default()
        .model(state.settings.ai.model_id.clone())
        .messages(vec![
            ChatCompletionRequestMessage::System(system_message),
            ChatCompletionRequestMessage::User(user_message),
        ])
        .n(1)
        .build()?;

    let response = state.ai.chat().create(request).await?;

    // dbg!(&response);

    let ai_content = response
        .choices
        .first()
        .and_then(|choice| choice.message.content.as_ref())
        .ok_or_else(|| AxumError::new(eyre!("No content generated by AI")))?;

    let model = note::ActiveModel {
        user_id: Set(user.id),
        title: Set(body.title),
        content: Set(ai_content.to_owned()),
        created_at: Set(Utc::now()),
        public: Set(body.public.unwrap_or(false)),
        ..Default::default()
    };

    let inserted = model.insert(&state.db).await?;

    Ok(Json(AiNoteCreateResponse {
        content: ai_content.to_owned(),
        id: inserted.id,
    }))
}

#[derive(Serialize, ToSchema)]
pub struct AiNoteCreateResponse {
    pub content: String,
    pub id: i32,
}
